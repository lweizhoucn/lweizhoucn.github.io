<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lweizhoucn</title>
  
  <subtitle>一切随缘，安得自在。</subtitle>
  <link href="https://weizhoucn.githubio.io/atom.xml" rel="self"/>
  
  <link href="https://weizhoucn.githubio.io/"/>
  <updated>2020-08-27T07:54:50.373Z</updated>
  <id>https://weizhoucn.githubio.io/</id>
  
  <author>
    <name>lweizhoucn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作流一目了然，看小姐姐用动图展示10大Git命令</title>
    <link href="https://weizhoucn.githubio.io/posts/1267633375/"/>
    <id>https://weizhoucn.githubio.io/posts/1267633375/</id>
    <published>2020-08-27T05:19:27.000Z</published>
    <updated>2020-08-27T07:54:50.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>装载自 <a href="https://mp.weixin.qq.com/s/PUUL913fig6cFfqy4OKcGA">工作流一目了然，看小姐姐用动图展示10大Git命令</a></p></blockquote><h2 id="合并">合并</h2><p>拥有多个分支是很方便的，这样可以将不同的新修改互相隔离开，而且还能确保你不会意外地向生产代码推送未经许可或破损的代码修改。但一旦这些修改得到了批准许可，我们就需要将其部署到我们的生产分支中！</p><p>可将一个分支的修改融入到另一个分支的一种方式是执行 git merge。Git 可执行两种类型的合并：fast-forward 和 no-fast-forward。现在你可能分不清，但我们马上就来看看它们的差异所在。</p><a id="more"></a><h3 id="Fast-forward-—ff">Fast-forward (—ff)</h3><p>在当前分支相比于我们要合并的分支没有额外的提交（commit）时，可以执行 fast-forward 合并。Git 很懒，首先会尝试执行最简单的选项：fast-forward！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。</p><p><img src="/posts/1267633375/1.gif" alt></p><p>完美！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。那么 no-fast-forward 又是什么意思呢？</p><h3 id="No-fast-foward-—no-ff">No-fast-foward (—no-ff)</h3><p>如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git 将会执行 no-fast-forward 合并。</p><p>使用 no-fast-forward 合并时，Git 会在当前活动分支上创建新的 merging commit。这个提交的父提交（parent commit）即指向这个活动分支，也指向我们想要合并的分支！</p><p><img src="/posts/1267633375/2.gif" alt></p><p>没什么大不了的，完美的合并！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。</p><h2 id="合并冲突">合并冲突</h2><p>尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git 就不知道如何取舍了。</p><p>在这样的情况下，Git 会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了 <a href="http://README.md">README.md</a> 的第一行。</p><p><img src="/posts/1267633375/3.png" alt></p><p>如果我们想把 dev 合并到 master，就会出现一个合并冲突：你想要标题是 Hello! 还是 Hey!？</p><p>当尝试合并这些分支时，Git 会向你展示冲突出现的位置。我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。</p><p><img src="/posts/1267633375/4.gif" alt></p><p>完成！尽管合并冲突往往很让人厌烦，但这是合理的：Git 不应该瞎猜我们想要保留哪些修改。</p><h2 id="变基（Rebasing）">变基（Rebasing）</h2><p>我们刚看到可通过执行 git merge 将一个分支的修改应用到另一个分支。另一种可将一个分支的修改融入到另一个分支的方式是执行 git rebase。</p><p>git rebase 会将当前分支的提交复制到指定的分支之上。</p><p><img src="/posts/1267633375/5.gif" alt></p><p>完美，现在我们在 dev 分支上获取了 master 分支上的所有修改。</p><p>变基与合并有一个重大的区别：Git 不会尝试确定要保留或不保留哪些文件。我们执行 rebase 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录。</p><p>上面这个例子展示了在 master 分支上的变基。但是，在更大型的项目中，你通常不需要这样的操作。git rebase 在为复制的提交创建新的 hash 时会修改项目的历史记录。</p><p>如果你在开发一个 feature 分支并且 master 分支已经更新过，那么变基就很好用。你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。</p><h2 id="交互式变基（Interactive-Rebase）">交互式变基（Interactive Rebase）</h2><p>在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。</p><p>在我们正在 rebase 的提交上，我们可以执行以下 6 个动作</p><ul><li>reword：修改提交信息；</li><li>edit：修改此提交；</li><li>squash：将提交融合到前一个提交中；</li><li>fixup：将提交融合到前一个提交中，不保留该提交的日志消息；</li><li>exec：在每个提交上运行我们想要 rebase 的命令；</li><li>drop：移除该提交。</li></ul><p>很棒！这样我们就能完全控制我们的提交了。如果你想要移除一个提交，只需 drop 即可。</p><p><img src="/posts/1267633375/6.gif" alt></p><p>如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！</p><p><img src="/posts/1267633375/7.gif" alt></p><p>交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。</p><h2 id="重置（Resetting）">重置（Resetting）</h2><p>当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 WIP 提交或者可能是引入了 bug 的提交，这时候就要执行 git reset。</p><p>git reset 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。</p><h3 id="软重置">软重置</h3><p>软重置会将 HEAD 移至指定的提交（或与 HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！</p><p>假设我们不想保留添加了一个 style.css 文件的提交 9e78i，而且我们也不想保留添加了一个 index.js 文件的提交 035cc。但是，我们确实又想要保留新添加的 style.css 和 index.js 文件！这是软重置的一个完美用例。</p><p><img src="/posts/1267633375/8.gif" alt></p><p>输入 git status 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！</p><h3 id="硬重置">硬重置</h3><p>有时候我们并不想保留特定提交引入的修改。不同于软重置，我们应该再也无需访问它们。Git 应该直接将整体状态直接重置到特定提交之前的状态：这甚至包括你在工作目录中和暂存文件上的修改。</p><p><img src="/posts/1267633375/9.gif" alt></p><p>Git 丢弃了 9e78i 和 035cc 引入的修改，并将状态重置到了 ec5be 的状态。</p><h2 id="还原（Reverting）">还原（Reverting）</h2><p>另一种撤销修改的方法是执行 git revert。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。</p><p>假设 ec5be 添加了一个 index.js 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！</p><p><img src="/posts/1267633375/10.gif" alt></p><p>完美！提交 9e78i 还原了由提交 ec5be 引入的修改。在撤销特定的提交时，git revert 非常有用，同时也不会修改分支的历史。</p><h2 id="拣选（Cherry-picking）">拣选（Cherry-picking）</h2><p>当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 cherry-pick！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。</p><p>假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。我们并不想要整个 dev 分支，而只需要这个提交！</p><p><img src="/posts/1267633375/11.gif" alt></p><p>现在 master 分支包含 76d12 引入的修改了。</p><h2 id="取回（Fetching）">取回（Fetching）</h2><p>如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。比如当合并了另一个分支或你的同事推送了一个快速修复时。</p><p>通过在这个远程分支上执行 git fetch，我们就可在本地获取这些修改。这不会以任何方式影响你的本地分支：fetch 只是单纯地下载新的数据而已。</p><p><img src="/posts/1267633375/12.gif" alt></p><p>现在我们可以看到自上次推送以来的所有修改了。这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。</p><h2 id="拉取（Pulling）">拉取（Pulling）</h2><p>尽管 git fetch 可用于获取某个分支的远程信息，但我们也可以执行 git pull。git pull 实际上是两个命令合成了一个：git fetch 和 git merge。当我们从来源拉取修改时，我们首先是像 git fetch 那样取回所有数据，然后最新的修改会自动合并到本地分支中。</p><p><img src="/posts/1267633375/13.gif" alt></p><p>很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！</p><h2 id="Reflog">Reflog</h2><p>每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。</p><p>git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。</p><p><img src="/posts/1267633375/14.gif" alt></p><p>如果你犯了错，你可以根据 reflog 提供的信息通过重置 HEAD 来轻松地重做！</p><p>假设我们实际上并不需要合并原有分支。当我们执行 git reflog 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。</p><p><img src="/posts/1267633375/15.gif" alt></p><p>我们可以看到最新的动作已被推送给 reflog。</p><p><em>原文链接：<a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1</a></em></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;装载自 &lt;a href=&quot;https://mp.weixin.qq.com/s/PUUL913fig6cFfqy4OKcGA&quot;&gt;工作流一目了然，看小姐姐用动图展示10大Git命令&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;合并&quot;&gt;合并&lt;/h2&gt;
&lt;p&gt;拥有多个分支是很方便的，这样可以将不同的新修改互相隔离开，而且还能确保你不会意外地向生产代码推送未经许可或破损的代码修改。但一旦这些修改得到了批准许可，我们就需要将其部署到我们的生产分支中！&lt;/p&gt;
&lt;p&gt;可将一个分支的修改融入到另一个分支的一种方式是执行 git merge。Git 可执行两种类型的合并：fast-forward 和 no-fast-forward。现在你可能分不清，但我们马上就来看看它们的差异所在。&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://weizhoucn.githubio.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo Next主题配置记录</title>
    <link href="https://weizhoucn.githubio.io/posts/4077416227/"/>
    <id>https://weizhoucn.githubio.io/posts/4077416227/</id>
    <published>2020-08-20T21:59:45.000Z</published>
    <updated>2020-08-27T07:54:50.373Z</updated>
    
    
    
    
    
    <category term="hexo" scheme="https://weizhoucn.githubio.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot优雅地配置日志</title>
    <link href="https://weizhoucn.githubio.io/posts/1722421508/"/>
    <id>https://weizhoucn.githubio.io/posts/1722421508/</id>
    <published>2020-08-20T19:16:43.000Z</published>
    <updated>2020-08-27T07:54:50.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下文章来源于程序员小明 ，作者小明<br>本文主要给大家介绍SpringBoot中如何通过sl4j日志组件优雅地记录日志。其实，我们入门 JAVA 的第一行代码就是一行日志，那你现在还在使用System.out.println(“Hello,小明!”)记录日志吗？</p></blockquote><h3 id="我经历过的日志组件">我经历过的日志组件</h3><p>我最开始接触的日志组件是Log4j</p><blockquote><p>Log4j 作为Apache的一个开放源代码的项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件等我们期望它输出到的地方；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p></blockquote><a id="more"></a><p>我们可以通过一个配置文件来灵活地进行上面的配置，而不需要修改应用的代码。Log4j作为当时作为最先比较流行的日志框架，给我们在应用开发和维护带来了很大的便捷。</p><p>但是，如今还是慢慢的走下“神坛”呢，逐渐被Logback替代，众里寻她千百度，原来Logback是升级版，相对Log4j而言有了更多的改进，而且开发人员竟然是同班人马（其实就是一个人写的）！</p><h3 id="新星Logback">新星Logback</h3><ol><li>更快的执行速度：基于我们先前在Log4j上的工作，Logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证Logback的组件更加快速的同时，同时所需的内存更加少；</li><li>充分的测试：Logback历经了几年，数不清小时数的测试。尽管Log4j也是测试过的，但是Logback的测试更加充分，跟Log4j不在同一个级别。我们认为，这正是人们选择Logback而不是Log4j的最重要的原因。谁不希望即使在恶劣的条件下，你的日志框架依然稳定而可靠呢？</li></ol><p>由三个模块组成</p><ul><li>logback-core</li><li>logback-classic</li><li>logback-access</li></ul><p>logback-core是其它模块的基础设施，其它模块基于它构建，显然，logback-core提供了一些关键的通用机制。logback-classic的地位和作用等同于 Log4J，它也被认为是 Log4J的一个改进版，并且它实现了简单日志门面 SLF4J；而logback-access主要作为一个与Servlet容器交互的模块，比如说tomcat或者jetty，提供一些与HTTP访问相关的功能。</p><h3 id="那Sl4J又是什么？">那Sl4J又是什么？</h3><blockquote><p>slf4j:The Simple Logging Facade for Java 即java的简单日志门面</p></blockquote><p>简答的讲就是slf4j是一系列的日志接口，slf4j是作为一个日志的抽象行为存在的，但是并没有提供真正的实现。</p><p>slf4j为各种日志框架提供了一个统一的界面，使用户可以用统一的接口记录日志，动态地决定要使用的实现框架，比如Logback，Log4j，common-logging等框架都实现了这些接口。</p><h3 id="我是如何配置日志的？">我是如何配置日志的？</h3><p>路人皆知，Springboot默认使用的日志框架是Logback。顺势而为，在项目中，我们使用Logback，其实只需增加一个配置文件（自定义你的配置）即可。</p><h3 id="配置文件详解">配置文件详解</h3><p>配置文件精简结构如下所示</p><p>这个文件在springboot中默认叫做logback-spring.xml，我们只要新建一个同名文件放在resources下面， 配置即可生效。</p><p>每个配置的解释如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 属性文件:在properties/yml文件中找到对应的配置项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;logging.path&quot;</span> <span class="attr">source</span>=<span class="string">&quot;logging.path&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>程序员小明<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span>&gt;</span></span><br><span class="line">        //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span>             </span><br><span class="line">       //xxxx</span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br></pre></td></tr></table></figure><h4 id="contextName">contextName</h4><p>每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用contextName标签设置成其他名字，用于区分不同应用程序的记录</p><h4 id="property">property</h4><p>用来定义变量值的标签，property标签有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过property定义的值会被插入到logger上下文中。定义变量后，可以使“${name}”来使用变量。如上面的xml所示。</p><h4 id="logger">logger</h4><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定appender。</p><h4 id="root">root</h4><p>根logger，也是一种logger，且只有一个level属性</p><h4 id="appender">appender</h4><p>负责写日志的组件</p><h5 id="appender的种类">appender的种类</h5><ul><li>ConsoleAppender：把日志添加到控制台</li><li>FileAppender：把日志添加到文件</li><li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li></ul><h4 id="filter">filter</h4><p>filter其实是appender里面的子元素。它作为过滤器存在，执行一个过滤器会有返回DENY，NEUTRAL，ACCEPT三个枚举值中的一个。</p><ul><li><p>DENY：日志将立即被抛弃不再经过其他过滤器</p></li><li><p>NEUTRAL：有序列表里的下个过滤器过接着处理日志</p></li><li><p>ACCEPT：日志会被立即处理，不再经过剩余过滤器</p></li></ul><h5 id="有以下几种过滤器">有以下几种过滤器</h5><h6 id="ThresholdFilter">ThresholdFilter</h6><p>临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回<mark>NEUTRAL</mark>；当日志级别低于临界值时，日志会被拒绝。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="LevelFilter">LevelFilter</h6><p>级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据onMath(用于配置符合过滤条件的操作) 和 onMismatch(用于配置不符合过滤条件的操作)接收或拒绝日志。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="项目实例">项目实例</h3><h4 id="准备">准备</h4><p>一个简单正常的Springboot项目</p><h4 id="配置文件">配置文件</h4><h5 id="application-yml">application.yml</h5><p>有关日志的简单配置，我们可以直接在application.yml中进行简单的配置，比如指明日志的打印级别和日志的输出位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./logs</span></span><br></pre></td></tr></table></figure><p>也可以根据分环境配置指明使用的配置文件，缺省为<mark>logback-spring.xml</mark></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./logs</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">classpath:/logback-dev.xml</span></span><br></pre></td></tr></table></figure><h5 id="logback-spring-xml">logback-spring.xml</h5><p>在resources目录下新建logback-spring.xml文件，举例一个简单的需求，如果在项目中我们如果需要指定日志的输出格式以及根据日志级别输出到不同的文件，可以配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性文件:在properties文件中找到对应的配置项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;logging.path&quot;</span> <span class="attr">source</span>=<span class="string">&quot;logging.path&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>xiaoming<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出（配色）：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%yellow(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %red([%thread]) %highlight(%-5level) %cyan(%logger&#123;50&#125;) - %magenta(%msg) %n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据日志级别分离日志，分别输出到不同的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;fileInfoLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--按时间保存日志 修改格式可以按小时、按天、月来保存--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/xiaoming.info.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--保存时长--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--文件大小--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>1GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;fileErrorLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/xiaoming.error.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleLog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;fileInfoLog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;fileErrorLog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再比如如果粒度再细一些，根据不同的模块，输出到不同的文件，可以如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--特殊功能单独appender 例如调度类的日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CLASS-APPENDER&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;logging.path&#125;/mkc.class.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的name和业务类中的getLogger中的字符串是一样的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;xiaoming&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CLASS-APPENDER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正常情况下xiaoming是指的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger xiaoming = LoggerFactory.getLogger(<span class="string">&quot;xiaoming&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果我们使用的是lomok插件，则xiaoming指的是topic</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;xiaoming&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他">其他</h4><p>小明目前用到的就这么多啦，更多的日志配置场景，大家可以访问：看完这个不会配置 logback ，请你吃瓜！<a href="https://note.youdao.com/">https://juejin.im/post/5b51f85c5188251af91a7525</a></p><p>来源: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzIwOTI2ODY3Nw==&amp;scene=161#wechat_redirect">https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzIwOTI2ODY3Nw==&amp;scene=161#wechat_redirect</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以下文章来源于程序员小明 ，作者小明&lt;br&gt;
本文主要给大家介绍SpringBoot中如何通过sl4j日志组件优雅地记录日志。其实，我们入门 JAVA 的第一行代码就是一行日志，那你现在还在使用System.out.println(“Hello,小明!”)记录日志吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;我经历过的日志组件&quot;&gt;我经历过的日志组件&lt;/h3&gt;
&lt;p&gt;我最开始接触的日志组件是Log4j&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Log4j 作为Apache的一个开放源代码的项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件等我们期望它输出到的地方；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="springboot" scheme="https://weizhoucn.githubio.io/categories/springboot/"/>
    
    
    <category term="springboot" scheme="https://weizhoucn.githubio.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Commit message 和 Change log 编写指南</title>
    <link href="https://weizhoucn.githubio.io/posts/2910968457/"/>
    <id>https://weizhoucn.githubio.io/posts/2910968457/</id>
    <published>2019-08-09T18:32:41.000Z</published>
    <updated>2020-08-27T07:54:50.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自 <a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></p></blockquote><p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>上面代码的-m参数，就是用来指定 commit mesage 的。</p><p>如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p><img src="/posts/2910968457/1.png" alt></p><p>但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。</p><p><img src="/posts/2910968457/2.png" alt></p><p>目前，社区有多种 Commit message 的写法规范。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular 规范</a>（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p><h2 id="Commit-message-的作用">Commit message 的作用</h2><p>格式化的Commit message，有几个好处。</p><h3 id="提供更多的历史信息，方便快速浏览。">提供更多的历史信息，方便快速浏览。</h3><p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure><p><img src="/posts/2910968457/3.png" alt></p><h3 id="可以过滤某些commit（比如文档改动），便于快速查找信息。">可以过滤某些commit（比如文档改动），便于快速查找信息。</h3><p>比如，下面的命令仅仅显示本次发布新增加的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure><h3 id="可以直接从commit生成Change-log。">可以直接从commit生成Change log。</h3><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。</p><p><img src="/posts/2910968457/4.png" alt></p><h2 id="Commit-message-的格式">Commit message 的格式</h2><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><h3 id="Header">Header</h3><p>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。</p><h4 id="type">type</h4><p><strong>type</strong> 用于说明 commit 的类别，只允许使用下面7个标识。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure><p>如果<mark>type</mark>为<strong>feat</strong>和<strong>fix</strong>，则该 commit 将肯定出现在 Change log 之中。其他情况（<strong>docs</strong>、<strong>chore</strong>、<strong>style</strong>、<strong>refactor</strong>、<strong>test</strong>）由你决定，要不要放入 Change log，建议是不要。</p><h4 id="scope">scope</h4><p><strong>scope</strong>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><h4 id="subject">subject</h4><p><strong>subject</strong>是 commit 目的的简短描述，不超过50个字符</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以动词开头，使用第一人称现在时，比如change，而不是changed或changes</span><br><span class="line">第一个字母小写</span><br><span class="line">结尾不加句号（.）</span><br></pre></td></tr></table></figure><h3 id="Body">Body</h3><p><strong>Body</strong> 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure><p>有两个注意点。</p><ul><li>使用第一人称现在时，比如使用<strong>change</strong>而不是<strong>changed</strong>或<strong>changes</strong>。</li><li>应该说明代码变动的动机，以及与以前行为的对比。</li></ul><h3 id="Footer">Footer</h3><p><strong>Footer</strong> 部分只用于两种情况</p><h4 id="不兼容变动">不兼容变动</h4><p>如果当前代码与上一个版本不兼容，则 <strong>Footer</strong> 部分以<strong>BREAKING CHANGE</strong>开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &#x27;attribute&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &#x27;@&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn&#x27;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure><h4 id="关闭-Issue">关闭 Issue</h4><p>如果当前 commit 针对某个issue，那么可以在 <strong>Footer</strong> 部分关闭这个 issue 。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #234</span><br></pre></td></tr></table></figure><p>也可以一次关闭多个 issue 。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure><h3 id="Revert">Revert</h3><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<font color="#F000000" size="4">revert:</font>开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt; .，其中的hash是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<strong>Reverts</strong>小标题下面。</p><h2 id="生成-Change-log">生成 Change log</h2><p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（例1，例2，例3）。</p><p>生成的文档包括以下三个部分。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">New features</span><br><span class="line">Bug fixes</span><br><span class="line">Breaking changes.</span><br></pre></td></tr></table></figure><p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p><p><a href="https://github.com/ajoslin/conventional-changelog">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog</span><br><span class="line">cd my-project</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure><p>上面命令不会覆盖以前的 Change log，只会在<strong><a href="http://CHANGELOG.md">CHANGELOG.md</a></strong>的头部加上自从上次发布以来的变动。</p><p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><p>为了方便使用，可以将其写入<strong>package.json</strong>的<strong>scripts</strong>字段。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;changelog&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，直接运行下面的命令即可。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&quot;&gt;Commit message 和 Change log 编写指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://weizhoucn.githubio.io/categories/git/"/>
    
    
  </entry>
  
</feed>
